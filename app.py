from flask import Flask, render_template, request, jsonify
import numpy as np
from PIL import Image
import base64
import io

app = Flask(__name__)

def создать_одиночную_щель(размер, ширина):
    апертура = np.zeros((размер, размер))
    центр = размер // 2
    полуширина = ширина // 2
    апертура[:, центр - полуширина:центр + полуширина] = 1.0
    return апертура

def создать_двойную_щель(размер, ширина, разделение):
    апертура = np.zeros((размер, размер))
    центр = размер // 2
    полуширина = ширина // 2
    полуразделение = разделение // 2
    апертура[:, центр - полуразделение - полуширина:центр - полуразделение + полуширина] = 1.0
    апертура[:, центр + полуразделение - полуширина:центр + полуразделение + полуширина] = 1.0
    return апертура

def создать_тройную_щель(размер, ширина, разделение):
    апертура = np.zeros((размер, размер))
    центр = размер // 2
    полуширина = ширина // 2
    апертура[:, центр - полуширина:центр + полуширина] = 1.0
    апертура[:, центр - разделение - полуширина:центр - разделение + полуширина] = 1.0
    апертура[:, центр + разделение - полуширина:центр + разделение + полуширина] = 1.0
    return апертура

def создать_круглое_отверстие(размер, радиус):
    апертура = np.zeros((размер, размер))
    центр = размер // 2
    y, x = np.ogrid[:размер, :размер]
    маска = (x - центр)**2 + (y - центр)**2 <= радиус**2
    апертура[маска] = 1.0
    return апертура

def создать_апертуру_из_изображения(данные_изображения, размер):
    try:
        if ',' in данные_изображения:
            данные_изображения = данные_изображения.split(',')[1]
        байты_изображения = base64.b64decode(данные_изображения)
        изображение = Image.open(io.BytesIO(байты_изображения)).convert('L')
        изображение = изображение.resize((размер, размер), Image.LANCZOS)
        апертура = np.array(изображение) / 255.0
        порог = 0.5
        апертура = (апертура > порог).astype(float)
        return апертура
    except Exception as e:
        print(f"Ошибка загрузки изображения: {e}")
        return создать_одиночную_щель(размер, 20)

def создать_апертуру_из_матрицы(данные_матрицы, размер):
    try:
        матрица = np.array(данные_матрицы, dtype=float)
        if матрица.size == 0:
            return создать_одиночную_щель(размер, 20)
        масштаб_y = размер // матрица.shape[0]
        масштаб_x = размер // матрица.shape[1]
        апертура = np.kron(матрица, np.ones((масштаб_y, масштаб_x)))
        if апертура.shape[0] != размер or апертура.shape[1] != размер:
            новая_апертура = np.zeros((размер, размер))
            мин_y = min(размер, апертура.shape[0])
            мин_x = min(размер, апертура.shape[1])
            новая_апертура[:мин_y, :мин_x] = апертура[:мин_y, :мин_x]
            апертура = новая_апертура
        return апертура
    except Exception as e:
        print(f"Ошибка создания апертуры из матрицы: {e}")
        return создать_одиночную_щель(размер, 20)

def дифракция_френеля(апертура, длина_волны, расстояние, размер_пикселя):
    размер = апертура.shape[0]
    k = 2 * np.pi / длина_волны

    fx = np.fft.fftfreq(размер, размер_пикселя)
    fy = np.fft.fftfreq(размер, размер_пикселя)
    FX, FY = np.meshgrid(fx, fy)

    число_френеля = (размер_пикселя * размер / 2)**2 / (длина_волны * расстояние)

    if число_френеля > 0.1:
        аргумент = 1 - (длина_волны * FX)**2 - (длина_волны * FY)**2
        аргумент = np.clip(аргумент, 0, None)
        H = np.exp(1j * k * расстояние * np.sqrt(аргумент))
        H[аргумент <= 0] = 0
    else:
        H = np.exp(-1j * np.pi * длина_волны * расстояние * (FX**2 + FY**2))

    U0 = np.fft.fft2(апертура)
    U = np.fft.ifft2(U0 * np.fft.fftshift(H))

    интенсивность = np.abs(U)**2

    if np.max(интенсивность) > 0:
        интенсивность = интенсивность / np.max(интенсивность)

    return интенсивность

def дифракция_фраунгофера(апертура, длина_волны, расстояние, размер_пикселя):
    размер = апертура.shape[0]

    дополненный_размер = размер * 2
    дополненная = np.zeros((дополненный_размер, дополненный_размер))
    начало = дополненный_размер // 4
    дополненная[начало:начало+размер, начало:начало+размер] = апертура

    фурье = np.fft.fftshift(np.fft.fft2(np.fft.fftshift(дополненная)))
    интенсивность = np.abs(фурье)**2

    центр = дополненный_размер // 2
    половина = размер // 2
    интенсивность = интенсивность[центр-половина:центр+половина, центр-половина:центр+половина]

    if np.max(интенсивность) > 0:
        интенсивность = интенсивность / np.max(интенсивность)

    return интенсивность

def применить_статистику_электронов(интенсивность, количество_электронов):
    вероятность = интенсивность.copy()
    сумма = np.sum(вероятность)
    if сумма > 0:
        вероятность = вероятность / сумма
    else:
        вероятность = np.ones_like(вероятность) / вероятность.size

    плоская_вероятность = вероятность.flatten()

    индексы = np.random.choice(len(плоская_вероятность), size=количество_электронов, p=плоская_вероятность)

    результат = np.zeros_like(плоская_вероятность)
    np.add.at(результат, индексы, 1)

    результат = результат.reshape(интенсивность.shape)

    сигма = 1.5
    from scipy.ndimage import gaussian_filter
    результат = gaussian_filter(результат, sigma=сигма)

    if np.max(результат) > 0:
        результат = результат / np.max(результат)

    return результат

def применить_статистику_электронов_простая(интенсивность, количество_электронов):
    вероятность = интенсивность.copy()
    сумма = np.sum(вероятность)
    if сумма > 0:
        вероятность = вероятность / сумма
    else:
        вероятность = np.ones_like(вероятность) / вероятность.size

    плоская_вероятность = вероятность.flatten()
    индексы = np.random.choice(len(плоская_вероятность), size=количество_электронов, p=плоская_вероятность)

    результат = np.zeros_like(плоская_вероятность)
    np.add.at(результат, индексы, 1)
    результат = результат.reshape(интенсивность.shape)

    размер_ядра = 3
    ядро = np.ones((размер_ядра, размер_ядра)) / (размер_ядра**2)
    from scipy.signal import convolve2d
    результат = convolve2d(результат, ядро, mode='same', boundary='wrap')

    if np.max(результат) > 0:
        результат = результат / np.max(результат)

    return результат

def массив_в_base64_png(массив):
    нормализованный = массив.copy()
    if np.max(нормализованный) > 0:
        нормализованный = нормализованный / np.max(нормализованный)

    uint8_массив = (нормализованный * 255).astype(np.uint8)
    изображение = Image.fromarray(uint8_массив, mode='L')

    буфер = io.BytesIO()
    изображение.save(буфер, format='PNG')
    строка_изображения = base64.b64encode(буфер.getvalue()).decode('utf-8')

    return f"data:image/png;base64,{строка_изображения}"

def применить_гамма_коррекцию(интенсивность, гамма=0.5):
    результат = np.power(интенсивность, гамма)
    if np.max(результат) > 0:
        результат = результат / np.max(результат)
    return результат

@app.route('/')
def главная():
    return render_template('index.html')

@app.route('/calculate', methods=['POST'])
def рассчитать():
    try:
        данные = request.get_json()

        тип_апертуры = данные.get('aperture_type', 'single')
        расстояние_экрана = float(данные.get('screen_distance', 1.0))
        количество_электронов = int(данные.get('num_electrons', 100000))
        ширина_щели = int(данные.get('slit_width', 20))
        разделение_щелей = int(данные.get('slit_separation', 60))
        радиус_круга = int(данные.get('circle_radius', 40))
        длина_волны = float(данные.get('wavelength', 5e-12))
        размер_пикселя = float(данные.get('pixel_size', 1e-7))
        данные_изображения = данные.get('image_data', None)
        данные_матрицы = данные.get('matrix_data', None)

        размер = 512

        количество_электронов = max(10000, min(1000000, количество_электронов))
        расстояние_экрана = max(0.001, min(100.0, расстояние_экрана))

        if тип_апертуры == 'single':
            апертура = создать_одиночную_щель(размер, ширина_щели)
        elif тип_апертуры == 'double':
            апертура = создать_двойную_щель(размер, ширина_щели, разделение_щелей)
        elif тип_апертуры == 'triple':
            апертура = создать_тройную_щель(размер, ширина_щели, разделение_щелей)
        elif тип_апертуры == 'circle':
            апертура = создать_круглое_отверстие(размер, радиус_круга)
        elif тип_апертуры == 'image' and данные_изображения:
            апертура = создать_апертуру_из_изображения(данные_изображения, размер)
        elif тип_апертуры == 'matrix' and данные_матрицы:
            апертура = создать_апертуру_из_матрицы(данные_матрицы, размер)
        else:
            апертура = создать_одиночную_щель(размер, ширина_щели)

        интенсивность_френеля = дифракция_френеля(апертура, длина_волны, расстояние_экрана, размер_пикселя)
        интенсивность_фраунгофера = дифракция_фраунгофера(апертура, длина_волны, расстояние_экрана * 1000, размер_пикселя)

        try:
            from scipy.ndimage import gaussian_filter
            френель_с_электронами = применить_статистику_электронов(интенсивность_френеля, количество_электронов)
            фраунгофер_с_электронами = применить_статистику_электронов(интенсивность_фраунгофера, количество_электронов)
        except ImportError:
            френель_с_электронами = применить_статистику_электронов_простая(интенсивность_френеля, количество_электронов)
            фраунгофер_с_электронами = применить_статистику_электронов_простая(интенсивность_фраунгофера, количество_электронов)

        френель_для_отображения = применить_гамма_коррекцию(френель_с_электронами, 0.4)
        фраунгофер_для_отображения = применить_гамма_коррекцию(фраунгофер_с_электронами, 0.4)

        изображение_апертуры = массив_в_base64_png(апертура)
        изображение_френеля = массив_в_base64_png(френель_для_отображения)
        изображение_фраунгофера = массив_в_base64_png(фраунгофер_для_отображения)

        return jsonify({
            'success': True,
            'aperture': изображение_апертуры,
            'fresnel': изображение_френеля,
            'fraunhofer': изображение_фраунгофера,
            'fresnel_number': float((размер_пикселя * размер / 2)**2 / (длина_волны * расстояние_экрана)),
            'info': {
                'wavelength': длина_волны,
                'distance': расстояние_экрана,
                'electrons': количество_электронов
            }
        })

    except Exception as e:
        import traceback
        return jsonify({
            'success': False,
            'error': str(e),
            'traceback': traceback.format_exc()
        }), 500

@app.route('/health')
def проверка_здоровья():
    return jsonify({'status': 'ok'})

if __name__ == '__main__':
    import os
    if not os.path.exists('templates'):
        os.makedirs('templates')
    if not os.path.exists('static'):
        os.makedirs('static')
    app.run(debug=True, host='127.0.0.1', port=5000)